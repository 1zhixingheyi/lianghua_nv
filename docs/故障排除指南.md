# é‡åŒ–äº¤æ˜“ç³»ç»Ÿæ•…éšœæ’é™¤æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—å¸®åŠ©ç”¨æˆ·å’Œè¿ç»´äººå‘˜å¿«é€Ÿè¯Šæ–­å’Œè§£å†³é‡åŒ–äº¤æ˜“ç³»ç»Ÿè¿è¡Œè¿‡ç¨‹ä¸­é‡åˆ°çš„å¸¸è§é—®é¢˜ã€‚æ¶µç›–ç³»ç»Ÿå¯åŠ¨ã€æ•°æ®è·å–ã€ç­–ç•¥è¿è¡Œã€äº¤æ˜“æ‰§è¡Œã€æ€§èƒ½ä¼˜åŒ–ç­‰å„ä¸ªæ–¹é¢çš„æ•…éšœå¤„ç†ã€‚

## ğŸš¨ å¿«é€Ÿè¯Šæ–­

### ç³»ç»Ÿå¥åº·æ£€æŸ¥

#### 1. åŸºç¡€æœåŠ¡æ£€æŸ¥
```bash
# æ£€æŸ¥ç³»ç»ŸæœåŠ¡çŠ¶æ€
sudo systemctl status mysql redis nginx

# æ£€æŸ¥ç«¯å£å ç”¨
netstat -tlnp | grep -E '(3306|6379|5000|80|443)'

# æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
ps aux | grep -E '(python|mysql|redis|nginx)'

# æ£€æŸ¥ç£ç›˜ç©ºé—´
df -h

# æ£€æŸ¥å†…å­˜ä½¿ç”¨
free -h

# æ£€æŸ¥CPUè´Ÿè½½
top -bn1 | head -5
```

#### 2. åº”ç”¨æœåŠ¡æ£€æŸ¥
```bash
# æ£€æŸ¥åº”ç”¨å¥åº·çŠ¶æ€
curl -f http://localhost:5000/health

# æ£€æŸ¥APIå“åº”
curl -f http://localhost:5000/api/dashboard/summary

# æ£€æŸ¥WebSocketè¿æ¥
python -c "
import websocket
try:
    ws = websocket.create_connection('ws://localhost:5000/ws')
    print('WebSocketè¿æ¥æ­£å¸¸')
    ws.close()
except Exception as e:
    print(f'WebSocketè¿æ¥å¤±è´¥: {e}')
"

# æ£€æŸ¥æ•°æ®åº“è¿æ¥
python -c "
from data.database import get_database_manager
try:
    db = get_database_manager()
    print('æ•°æ®åº“è¿æ¥æ­£å¸¸')
except Exception as e:
    print(f'æ•°æ®åº“è¿æ¥å¤±è´¥: {e}')
"
```

#### 3. æ—¥å¿—å¿«é€Ÿæ£€æŸ¥
```bash
# æŸ¥çœ‹åº”ç”¨é”™è¯¯æ—¥å¿—
tail -50 logs/app.log | grep -i error

# æŸ¥çœ‹ç³»ç»Ÿé”™è¯¯æ—¥å¿—
journalctl -u lianghua_vn --since "1 hour ago" | grep -i error

# æŸ¥çœ‹Nginxé”™è¯¯æ—¥å¿—
tail -50 /var/log/nginx/error.log

# æŸ¥çœ‹MySQLé”™è¯¯æ—¥å¿—
tail -50 /var/log/mysql/error.log
```

## ğŸ”§ å¸¸è§é—®é¢˜è§£å†³

### 1. ç³»ç»Ÿå¯åŠ¨é—®é¢˜

#### é—®é¢˜ï¼šåº”ç”¨å¯åŠ¨å¤±è´¥
**ç—‡çŠ¶**ï¼š
- `python run_monitor.py` æ— æ³•å¯åŠ¨
- æç¤ºæ¨¡å—å¯¼å…¥é”™è¯¯
- ç«¯å£å ç”¨é”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š

```bash
# æ£€æŸ¥Pythonç¯å¢ƒ
python --version
which python

# æ£€æŸ¥è™šæ‹Ÿç¯å¢ƒ
source venv/bin/activate
pip list

# é‡æ–°å®‰è£…ä¾èµ–
pip install --upgrade -r requirements.txt

# æ£€æŸ¥ç«¯å£å ç”¨
lsof -i :5000
# å¦‚æœç«¯å£è¢«å ç”¨ï¼Œæ€æ­»è¿›ç¨‹
sudo kill -9 <PID>

# æ£€æŸ¥ç¯å¢ƒå˜é‡
cat .env
export FLASK_ENV=development

# æ¸…ç†Pythonç¼“å­˜
find . -name "*.pyc" -delete
find . -name "__pycache__" -delete
```

#### é—®é¢˜ï¼šæ•°æ®åº“è¿æ¥å¤±è´¥
**ç—‡çŠ¶**ï¼š
- `Connection refused` é”™è¯¯
- `Access denied` é”™è¯¯
- æ•°æ®åº“è¶…æ—¶

**è§£å†³æ–¹æ¡ˆ**ï¼š

```bash
# æ£€æŸ¥MySQLæœåŠ¡
sudo systemctl status mysql
sudo systemctl start mysql

# æ£€æŸ¥æ•°æ®åº“é…ç½®
mysql -u root -p -e "SHOW DATABASES;"

# æµ‹è¯•æ•°æ®åº“è¿æ¥
mysql -h localhost -u lianghua -p lianghua_trading -e "SELECT 1;"

# é‡ç½®æ•°æ®åº“å¯†ç 
sudo mysql -u root -p
ALTER USER 'lianghua'@'localhost' IDENTIFIED BY 'new_password';
FLUSH PRIVILEGES;

# æ£€æŸ¥é˜²ç«å¢™
sudo ufw status
sudo ufw allow 3306

# ä¿®å¤æ•°æ®åº“æƒé™
GRANT ALL PRIVILEGES ON lianghua_trading.* TO 'lianghua'@'localhost';
FLUSH PRIVILEGES;
```

#### é—®é¢˜ï¼šRedisè¿æ¥å¤±è´¥
**ç—‡çŠ¶**ï¼š
- Redisè¿æ¥è¶…æ—¶
- è®¤è¯å¤±è´¥
- å†…å­˜ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**ï¼š

```bash
# æ£€æŸ¥RedisæœåŠ¡
sudo systemctl status redis
sudo systemctl start redis

# æµ‹è¯•Redisè¿æ¥
redis-cli ping
redis-cli -a password ping

# æ£€æŸ¥Redisé…ç½®
sudo vim /etc/redis/redis.conf
# ä¿®æ”¹ï¼š
# bind 127.0.0.1
# requirepass your_password

# æ¸…ç†Rediså†…å­˜
redis-cli FLUSHDB
redis-cli FLUSHALL

# æ£€æŸ¥å†…å­˜ä½¿ç”¨
redis-cli INFO memory

# é‡å¯RedisæœåŠ¡
sudo systemctl restart redis
```

### 2. æ•°æ®è·å–é—®é¢˜

#### é—®é¢˜ï¼šTushareæ•°æ®è·å–å¤±è´¥
**ç—‡çŠ¶**ï¼š
- APIè°ƒç”¨é¢‘ç‡é™åˆ¶
- Tokenæ— æ•ˆ
- æ•°æ®ç¼ºå¤±

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# æ£€æŸ¥Tokenæœ‰æ•ˆæ€§
import tushare as ts
ts.set_token('your_token')
pro = ts.pro_api()

try:
    df = pro.stock_basic(exchange='', list_status='L', fields='ts_code,symbol,name')
    print("Tokenæœ‰æ•ˆï¼Œæ•°æ®è·å–æ­£å¸¸")
except Exception as e:
    print(f"Tokenæˆ–ç½‘ç»œé—®é¢˜: {e}")

# æ£€æŸ¥APIè°ƒç”¨é¢‘ç‡
import time

def safe_api_call(func, *args, **kwargs):
    max_retries = 3
    for i in range(max_retries):
        try:
            result = func(*args, **kwargs)
            return result
        except Exception as e:
            if "é¢‘ç‡" in str(e) or "limit" in str(e).lower():
                wait_time = (i + 1) * 60  # é€’å¢ç­‰å¾…æ—¶é—´
                print(f"APIè°ƒç”¨é¢‘ç‡é™åˆ¶ï¼Œç­‰å¾…{wait_time}ç§’...")
                time.sleep(wait_time)
            else:
                raise e
    raise Exception("APIè°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°")

# ä½¿ç”¨ç¤ºä¾‹
df = safe_api_call(pro.daily, ts_code='000001.SZ', start_date='20230101')
```

#### é—®é¢˜ï¼šæ•°æ®æ›´æ–°å»¶è¿Ÿ
**ç—‡çŠ¶**ï¼š
- è‚¡ä»·æ•°æ®ä¸æ˜¯æœ€æ–°çš„
- æŒ‡æ ‡è®¡ç®—é”™è¯¯
- å›æµ‹ç»“æœå¼‚å¸¸

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# æ‰‹åŠ¨æ›´æ–°æ•°æ®
from data.data_manager import DataManager

dm = DataManager()

# æ›´æ–°è‚¡ç¥¨åŸºç¡€ä¿¡æ¯
dm.update_stock_basic()

# æ›´æ–°æ—¥çº¿æ•°æ®
dm.update_daily_data()

# æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
symbols = ['000001.SZ', '000002.SZ', '600000.SH']
for symbol in symbols:
    latest_date = dm.get_latest_date(symbol)
    print(f"{symbol} æœ€æ–°æ•°æ®æ—¥æœŸ: {latest_date}")

# æ•°æ®éªŒè¯
import pandas as pd
from datetime import datetime, timedelta

today = datetime.now().date()
trade_dates = dm.get_trade_dates(today - timedelta(days=30), today)
missing_dates = []

for date in trade_dates:
    data_count = dm.get_daily_data_count(date)
    if data_count < 3000:  # å‡è®¾å¸‚åœºæœ‰3000+è‚¡ç¥¨
        missing_dates.append(date)

if missing_dates:
    print(f"ç¼ºå¤±æ•°æ®çš„æ—¥æœŸ: {missing_dates}")
```

### 3. ç­–ç•¥è¿è¡Œé—®é¢˜

#### é—®é¢˜ï¼šç­–ç•¥æŠ¥é”™
**ç—‡çŠ¶**ï¼š
- ç­–ç•¥åˆå§‹åŒ–å¤±è´¥
- æŒ‡æ ‡è®¡ç®—é”™è¯¯
- è®¢å•ç”Ÿæˆå¼‚å¸¸

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# ç­–ç•¥è°ƒè¯•æ¨¡å¼
import logging
logging.basicConfig(level=logging.DEBUG)

from strategies.rsi_strategy import RSIStrategy

# åˆ›å»ºæµ‹è¯•ç¯å¢ƒ
class MockContext:
    def __init__(self):
        self.portfolio = MockPortfolio()
        self.universe = ['000001.SZ']

class MockPortfolio:
    def __init__(self):
        self.total_value = 1000000
        self.cash = 1000000
        self.positions = {}

# æµ‹è¯•ç­–ç•¥
try:
    strategy = RSIStrategy('test_rsi', {
        'symbol': '000001.SZ',
        'rsi_period': 14,
        'rsi_upper': 70,
        'rsi_lower': 30
    })
    
    context = MockContext()
    strategy.initialize(context)
    print("ç­–ç•¥åˆå§‹åŒ–æˆåŠŸ")
    
except Exception as e:
    print(f"ç­–ç•¥é”™è¯¯: {e}")
    import traceback
    traceback.print_exc()

# å‚æ•°éªŒè¯
def validate_strategy_params(strategy_class, params):
    required_params = getattr(strategy_class, 'REQUIRED_PARAMS', [])
    for param in required_params:
        if param not in params:
            raise ValueError(f"ç¼ºå°‘å¿…éœ€å‚æ•°: {param}")
    
    # å‚æ•°èŒƒå›´æ£€æŸ¥
    if 'rsi_period' in params and not (1 <= params['rsi_period'] <= 100):
        raise ValueError("RSIå‘¨æœŸå¿…é¡»åœ¨1-100ä¹‹é—´")
        
    if 'rsi_upper' in params and not (50 <= params['rsi_upper'] <= 100):
        raise ValueError("RSIä¸Šé™å¿…é¡»åœ¨50-100ä¹‹é—´")
```

#### é—®é¢˜ï¼šå›æµ‹ç»“æœå¼‚å¸¸
**ç—‡çŠ¶**ï¼š
- æ”¶ç›Šç‡è¿‡é«˜æˆ–è¿‡ä½
- å¤æ™®æ¯”ç‡å¼‚å¸¸
- æœ€å¤§å›æ’¤è¿‡å¤§

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# å›æµ‹ç»“æœéªŒè¯
from backtest.engine import BacktestEngine
from backtest.performance import PerformanceAnalyzer

def validate_backtest_results(results):
    """éªŒè¯å›æµ‹ç»“æœåˆç†æ€§"""
    
    # æ£€æŸ¥åŸºæœ¬æŒ‡æ ‡
    if results['total_return'] > 10:  # å¹´åŒ–æ”¶ç›Šç‡è¶…è¿‡1000%
        print("è­¦å‘Šï¼šæ”¶ç›Šç‡å¼‚å¸¸è¿‡é«˜ï¼Œå¯èƒ½å­˜åœ¨æœªæ¥å‡½æ•°")
    
    if results['sharpe_ratio'] > 5:  # å¤æ™®æ¯”ç‡è¿‡é«˜
        print("è­¦å‘Šï¼šå¤æ™®æ¯”ç‡å¼‚å¸¸ï¼Œæ£€æŸ¥é£é™©è®¡ç®—")
    
    if results['max_drawdown'] > 0.8:  # æœ€å¤§å›æ’¤è¶…è¿‡80%
        print("è­¦å‘Šï¼šæœ€å¤§å›æ’¤è¿‡å¤§ï¼Œæ£€æŸ¥é£æ§è®¾ç½®")
    
    # æ£€æŸ¥äº¤æ˜“é¢‘ç‡
    trading_days = len(results['daily_returns'])
    total_trades = results['total_trades']
    if total_trades / trading_days > 2:  # å¹³å‡æ¯å¤©äº¤æ˜“è¶…è¿‡2æ¬¡
        print("è­¦å‘Šï¼šäº¤æ˜“é¢‘ç‡è¿‡é«˜ï¼Œå¯èƒ½å½±å“æˆæœ¬")
    
    # æ£€æŸ¥èƒœç‡
    win_rate = results['win_rate']
    if win_rate > 0.9 or win_rate < 0.3:
        print(f"è­¦å‘Šï¼šèƒœç‡å¼‚å¸¸ ({win_rate:.2%})ï¼Œæ£€æŸ¥ä¿¡å·é€»è¾‘")

# åˆ†æ­¥è°ƒè¯•å›æµ‹
def debug_backtest(strategy, start_date, end_date):
    """åˆ†æ­¥è°ƒè¯•å›æµ‹è¿‡ç¨‹"""
    
    engine = BacktestEngine(strategy, start_date, end_date, 1000000)
    
    # æ£€æŸ¥æ•°æ®
    data = engine.get_data()
    print(f"æ•°æ®èŒƒå›´: {data.index.min()} åˆ° {data.index.max()}")
    print(f"æ•°æ®ç‚¹æ•°: {len(data)}")
    
    # æ£€æŸ¥ä¿¡å·
    signals = engine.generate_signals()
    print(f"ä¿¡å·æ•°é‡: {len(signals)}")
    print(f"ä¹°å…¥ä¿¡å·: {sum(1 for s in signals if s['action'] == 'buy')}")
    print(f"å–å‡ºä¿¡å·: {sum(1 for s in signals if s['action'] == 'sell')}")
    
    # é€æ—¥æ‰§è¡Œ
    for i, (date, row) in enumerate(data.iterrows()):
        if i % 100 == 0:  # æ¯100å¤©æ‰“å°ä¸€æ¬¡çŠ¶æ€
            portfolio_value = engine.get_portfolio_value(date)
            print(f"æ—¥æœŸ: {date}, ç»„åˆä»·å€¼: {portfolio_value:,.2f}")
```

### 4. äº¤æ˜“æ‰§è¡Œé—®é¢˜

#### é—®é¢˜ï¼šQMTè¿æ¥å¤±è´¥
**ç—‡çŠ¶**ï¼š
- æ— æ³•è¿æ¥åˆ°QMTå®¢æˆ·ç«¯
- ç™»å½•å¤±è´¥
- äº¤æ˜“æƒé™ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# QMTè¿æ¥è¯Šæ–­
from trading.qmt_trader import QMTTrader

def diagnose_qmt_connection():
    """è¯Šæ–­QMTè¿æ¥é—®é¢˜"""
    
    try:
        # æ£€æŸ¥QMTè¿›ç¨‹
        import psutil
        qmt_processes = [p for p in psutil.process_iter() if 'qmt' in p.name().lower()]
        if not qmt_processes:
            print("é”™è¯¯ï¼šQMTå®¢æˆ·ç«¯æœªè¿è¡Œ")
            return False
        
        # å°è¯•è¿æ¥
        trader = QMTTrader()
        
        # æ£€æŸ¥ç™»å½•çŠ¶æ€
        if not trader.is_logged_in():
            print("é”™è¯¯ï¼šQMTæœªç™»å½•")
            return False
        
        # æ£€æŸ¥è´¦æˆ·ä¿¡æ¯
        account_info = trader.get_account_info()
        print(f"è´¦æˆ·ä¿¡æ¯: {account_info}")
        
        # æ£€æŸ¥äº¤æ˜“æƒé™
        permissions = trader.get_trading_permissions()
        if not permissions.get('stock_trading', False):
            print("é”™è¯¯ï¼šè‚¡ç¥¨äº¤æ˜“æƒé™ä¸è¶³")
            return False
        
        print("QMTè¿æ¥æ­£å¸¸")
        return True
        
    except Exception as e:
        print(f"QMTè¿æ¥é”™è¯¯: {e}")
        return False

# QMTé…ç½®æ£€æŸ¥
def check_qmt_config():
    """æ£€æŸ¥QMTé…ç½®"""
    
    import os
    from config import QMT_CONFIG
    
    # æ£€æŸ¥QMTè·¯å¾„
    qmt_path = QMT_CONFIG.get('path')
    if not os.path.exists(qmt_path):
        print(f"é”™è¯¯ï¼šQMTè·¯å¾„ä¸å­˜åœ¨: {qmt_path}")
        return False
    
    # æ£€æŸ¥ç«¯å£é…ç½®
    port = QMT_CONFIG.get('port', 58610)
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    result = sock.connect_ex(('localhost', port))
    sock.close()
    
    if result != 0:
        print(f"é”™è¯¯ï¼šQMTç«¯å£ {port} æ— æ³•è¿æ¥")
        return False
    
    return True
```

#### é—®é¢˜ï¼šè®¢å•æ‰§è¡Œå¤±è´¥
**ç—‡çŠ¶**ï¼š
- è®¢å•è¢«æ‹’ç»
- ä»·æ ¼åå·®è¿‡å¤§
- èµ„é‡‘ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# è®¢å•éªŒè¯å’Œé‡è¯•æœºåˆ¶
class OrderManager:
    def __init__(self):
        self.max_retries = 3
        self.retry_delay = 1  # ç§’
    
    def place_order_with_retry(self, symbol, quantity, price, order_type):
        """å¸¦é‡è¯•çš„ä¸‹å•"""
        
        for attempt in range(self.max_retries):
            try:
                # é¢„æ£€æŸ¥
                if not self.pre_order_check(symbol, quantity, price):
                    return None
                
                # æ‰§è¡Œä¸‹å•
                order_id = self.trader.place_order(symbol, quantity, price, order_type)
                
                # éªŒè¯è®¢å•
                if self.verify_order(order_id):
                    return order_id
                
            except Exception as e:
                print(f"ä¸‹å•å¤±è´¥ (å°è¯• {attempt + 1}/{self.max_retries}): {e}")
                
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay * (attempt + 1))
                else:
                    print("ä¸‹å•å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°")
                    raise
        
        return None
    
    def pre_order_check(self, symbol, quantity, price):
        """è®¢å•é¢„æ£€æŸ¥"""
        
        # æ£€æŸ¥èµ„é‡‘
        account_info = self.trader.get_account_info()
        required_cash = quantity * price * 1.01  # åŠ 1%ç¼“å†²
        
        if account_info['available_cash'] < required_cash:
            print(f"èµ„é‡‘ä¸è¶³: éœ€è¦ {required_cash:,.2f}, å¯ç”¨ {account_info['available_cash']:,.2f}")
            return False
        
        # æ£€æŸ¥ä»·æ ¼åˆç†æ€§
        current_price = self.get_current_price(symbol)
        if abs(price - current_price) / current_price > 0.1:  # ä»·æ ¼åå·®è¶…è¿‡10%
            print(f"ä»·æ ¼åå·®è¿‡å¤§: å½“å‰ {current_price}, å§”æ‰˜ {price}")
            return False
        
        # æ£€æŸ¥è‚¡ç¥¨çŠ¶æ€
        stock_info = self.get_stock_info(symbol)
        if stock_info['status'] != 'trading':
            print(f"è‚¡ç¥¨ {symbol} åœç‰Œæˆ–å¼‚å¸¸")
            return False
        
        return True
```

### 5. æ€§èƒ½é—®é¢˜

#### é—®é¢˜ï¼šç³»ç»Ÿå“åº”æ…¢
**ç—‡çŠ¶**ï¼š
- é¡µé¢åŠ è½½ç¼“æ…¢
- APIå“åº”è¶…æ—¶
- å†…å­˜ä½¿ç”¨è¿‡é«˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

```bash
# æ€§èƒ½ç›‘æ§
# 1. æ£€æŸ¥ç³»ç»Ÿèµ„æº
htop
iotop
nethogs

# 2. æ£€æŸ¥æ•°æ®åº“æ€§èƒ½
# MySQLæ…¢æŸ¥è¯¢
sudo mysql -e "
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;
SHOW VARIABLES LIKE 'slow_query%';
"

# åˆ†ææ…¢æŸ¥è¯¢æ—¥å¿—
sudo mysqldumpslow /var/log/mysql/slow.log

# 3. æ£€æŸ¥Redisæ€§èƒ½
redis-cli INFO stats
redis-cli SLOWLOG GET 10

# 4. åº”ç”¨æ€§èƒ½åˆ†æ
python -m cProfile -o profile.stats run_monitor.py
python -c "
import pstats
p = pstats.Stats('profile.stats')
p.sort_stats('cumulative').print_stats(20)
"
```

#### é—®é¢˜ï¼šå†…å­˜æ³„æ¼
**ç—‡çŠ¶**ï¼š
- å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
- ç³»ç»Ÿå˜æ…¢
- OOMé”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# å†…å­˜ç›‘æ§å’Œè¯Šæ–­
import psutil
import gc
import tracemalloc

class MemoryMonitor:
    def __init__(self):
        self.start_memory = psutil.Process().memory_info().rss
        tracemalloc.start()
    
    def check_memory(self, operation_name):
        """æ£€æŸ¥å†…å­˜ä½¿ç”¨"""
        current_memory = psutil.Process().memory_info().rss
        memory_diff = current_memory - self.start_memory
        
        print(f"{operation_name}: å†…å­˜ä½¿ç”¨ {current_memory / 1024 / 1024:.1f}MB "
              f"(å¢é•¿ {memory_diff / 1024 / 1024:.1f}MB)")
        
        # æ£€æŸ¥å†…å­˜å¢é•¿
        if memory_diff > 100 * 1024 * 1024:  # è¶…è¿‡100MB
            print("è­¦å‘Šï¼šå†…å­˜ä½¿ç”¨å¼‚å¸¸å¢é•¿")
            self.dump_memory_usage()
    
    def dump_memory_usage(self):
        """è¾“å‡ºå†…å­˜ä½¿ç”¨è¯¦æƒ…"""
        snapshot = tracemalloc.take_snapshot()
        top_stats = snapshot.statistics('lineno')
        
        print("å†…å­˜ä½¿ç”¨TOP 10:")
        for index, stat in enumerate(top_stats[:10], 1):
            print(f"{index}. {stat}")

# ä½¿ç”¨ç¤ºä¾‹
monitor = MemoryMonitor()

# åœ¨å…³é”®æ“ä½œåæ£€æŸ¥å†…å­˜
data = load_large_dataset()
monitor.check_memory("åŠ è½½æ•°æ®é›†")

results = run_backtest()
monitor.check_memory("è¿è¡Œå›æµ‹")

# å¼ºåˆ¶åƒåœ¾å›æ”¶
gc.collect()
monitor.check_memory("åƒåœ¾å›æ”¶å")
```

### 6. ç½‘ç»œé—®é¢˜

#### é—®é¢˜ï¼šæ•°æ®æºè¿æ¥è¶…æ—¶
**ç—‡çŠ¶**ï¼š
- Tushare APIè¶…æ—¶
- ç½‘ç»œè¯·æ±‚å¤±è´¥
- ä»£ç†é…ç½®é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# ç½‘ç»œè¿æ¥è¯Šæ–­å’Œé‡è¯•
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

class RobustHTTPSession:
    def __init__(self):
        self.session = requests.Session()
        
        # é…ç½®é‡è¯•ç­–ç•¥
        retry_strategy = Retry(
            total=3,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["HEAD", "GET", "OPTIONS"],
            backoff_factor=1
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        # è®¾ç½®è¶…æ—¶
        self.session.timeout = 30
        
        # è®¾ç½®ä»£ç†ï¼ˆå¦‚æœéœ€è¦ï¼‰
        # self.session.proxies = {'http': 'proxy:port', 'https': 'proxy:port'}
    
    def get(self, url, **kwargs):
        """å®‰å…¨çš„GETè¯·æ±‚"""
        try:
            response = self.session.get(url, **kwargs)
            response.raise_for_status()
            return response
        except requests.exceptions.Timeout:
            print(f"è¯·æ±‚è¶…æ—¶: {url}")
            raise
        except requests.exceptions.ConnectionError:
            print(f"è¿æ¥é”™è¯¯: {url}")
            raise
        except requests.exceptions.HTTPError as e:
            print(f"HTTPé”™è¯¯: {e}")
            raise

# ç½‘ç»œè¯Šæ–­å·¥å…·
def diagnose_network():
    """ç½‘ç»œè¯Šæ–­"""
    
    import subprocess
    
    # æ£€æŸ¥DNSè§£æ
    try:
        result = subprocess.run(['nslookup', 'api.tushare.pro'], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            print("DNSè§£ææ­£å¸¸")
        else:
            print("DNSè§£æå¤±è´¥")
    except subprocess.TimeoutExpired:
        print("DNSæŸ¥è¯¢è¶…æ—¶")
    
    # æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
    test_urls = [
        'https://api.tushare.pro',
        'https://www.baidu.com',
        'https://www.google.com'
    ]
    
    session = RobustHTTPSession()
    for url in test_urls:
        try:
            response = session.get(url)
            print(f"âœ“ {url} - çŠ¶æ€ç : {response.status_code}")
        except Exception as e:
            print(f"âœ— {url} - é”™è¯¯: {e}")
```

## ğŸ“Š æ—¥å¿—åˆ†æ

### æ—¥å¿—çº§åˆ«è¯´æ˜

```python
# æ—¥å¿—çº§åˆ«å’Œå«ä¹‰
logging.DEBUG    # è°ƒè¯•ä¿¡æ¯ï¼Œè¯¦ç»†çš„æ‰§è¡Œæµç¨‹
logging.INFO     # ä¸€èˆ¬ä¿¡æ¯ï¼Œæ­£å¸¸çš„ä¸šåŠ¡æµç¨‹
logging.WARNING  # è­¦å‘Šä¿¡æ¯ï¼Œæ½œåœ¨é—®é¢˜
logging.ERROR    # é”™è¯¯ä¿¡æ¯ï¼Œç¨‹åºå¼‚å¸¸ä½†å¯ç»§ç»­
logging.CRITICAL # ä¸¥é‡é”™è¯¯ï¼Œç¨‹åºæ— æ³•ç»§ç»­
```

### å¸¸è§æ—¥å¿—æ¨¡å¼

#### 1. é”™è¯¯æ—¥å¿—åˆ†æ
```bash
# æŸ¥æ‰¾é”™è¯¯æ¨¡å¼
grep -E "(ERROR|CRITICAL)" logs/app.log | tail -20

# ç»Ÿè®¡é”™è¯¯ç±»å‹
grep "ERROR" logs/app.log | awk '{print $5}' | sort | uniq -c | sort -nr

# æŸ¥æ‰¾ç‰¹å®šæ—¶é—´æ®µçš„é”™è¯¯
grep "2023-12-01" logs/app.log | grep "ERROR"

# åˆ†æé”™è¯¯è¶‹åŠ¿
for hour in {00..23}; do
    count=$(grep "2023-12-01 $hour:" logs/app.log | grep "ERROR" | wc -l)
    echo "$hour:00 - $count errors"
done
```

#### 2. æ€§èƒ½æ—¥å¿—åˆ†æ
```bash
# æŸ¥æ‰¾æ…¢è¯·æ±‚
grep "æ‰§è¡Œæ—¶é—´" logs/app.log | awk '$NF > 5' | tail -10

# åˆ†æAPIå“åº”æ—¶é—´
grep "APIå“åº”æ—¶é—´" logs/app.log | awk '{print $NF}' | sort -n | tail -10

# ç»Ÿè®¡è¯·æ±‚é‡
grep "APIè¯·æ±‚" logs/app.log | awk '{print $2}' | cut -d: -f1 | sort | uniq -c
```

### æ—¥å¿—å‘Šè­¦è§„åˆ™

```python
# æ—¥å¿—ç›‘æ§è„šæœ¬
import re
import time
from collections import defaultdict

class LogMonitor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.error_patterns = [
            r'ERROR.*Database connection failed',
            r'CRITICAL.*Out of memory',
            r'ERROR.*Strategy.*failed',
            r'WARNING.*High memory usage'
        ]
        self.alert_thresholds = {
            'error_rate': 10,  # æ¯åˆ†é’Ÿé”™è¯¯æ•°
            'memory_usage': 80,  # å†…å­˜ä½¿ç”¨ç™¾åˆ†æ¯”
            'response_time': 5000  # å“åº”æ—¶é—´æ¯«ç§’
        }
    
    def monitor(self):
        """ç›‘æ§æ—¥å¿—æ–‡ä»¶"""
        error_counts = defaultdict(int)
        
        with open(self.log_file, 'r') as f:
            f.seek(0, 2)  # ç§»åˆ°æ–‡ä»¶æœ«å°¾
            
            while True:
                line = f.readline()
                if not line:
                    time.sleep(1)
                    continue
                
                # æ£€æŸ¥é”™è¯¯æ¨¡å¼
                for pattern in self.error_patterns:
                    if re.search(pattern, line):
                        error_counts[pattern] += 1
                        
                        # å‘é€å‘Šè­¦
                        self.send_alert(pattern, line)
                
                # é‡ç½®è®¡æ•°å™¨ï¼ˆæ¯åˆ†é’Ÿï¼‰
                if int(time.time()) % 60 == 0:
                    error_counts.clear()
    
    def send_alert(self, pattern, log_line):
        """å‘é€å‘Šè­¦"""
        print(f"ALERT: {pattern} - {log_line.strip()}")
        # è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰ç­‰å‘Šè­¦æ–¹å¼
```

## ğŸ”§ å·¥å…·å’Œè„šæœ¬

### è¯Šæ–­è„šæœ¬

```bash
#!/bin/bash
# scripts/system_check.sh - ç³»ç»Ÿè¯Šæ–­è„šæœ¬

echo "========== ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š =========="
echo "æ—¶é—´: $(date)"
echo

echo "1. ç³»ç»Ÿä¿¡æ¯:"
uname -a
echo "CPUæ ¸å¿ƒæ•°: $(nproc)"
echo "å†…å­˜æ€»é‡: $(free -h | grep Mem | awk '{print $2}')"
echo "ç£ç›˜ä½¿ç”¨: $(df -h / | tail -1 | awk '{print $5}')"
echo

echo "2. æœåŠ¡çŠ¶æ€:"
for service in mysql redis nginx; do
    if systemctl is-active --quiet $service; then
        echo "âœ“ $service è¿è¡Œä¸­"
    else
        echo "âœ— $service æœªè¿è¡Œ"
    fi
done
echo

echo "3. ç«¯å£æ£€æŸ¥:"
for port in 3306 6379 5000 80 443; do
    if netstat -tlnp | grep -q ":$port "; then
        echo "âœ“ ç«¯å£ $port å·²ç›‘å¬"
    else
        echo "âœ— ç«¯å£ $port æœªç›‘å¬"
    fi
done
echo

echo "4. åº”ç”¨å¥åº·æ£€æŸ¥:"
if curl -sf http://localhost:5000/health > /dev/null; then
    echo "âœ“ åº”ç”¨å¥åº·æ£€æŸ¥é€šè¿‡"
else
    echo "âœ— åº”ç”¨å¥åº·æ£€æŸ¥å¤±è´¥"
fi
echo

echo "5. æœ€è¿‘é”™è¯¯æ—¥å¿—:"
if [ -f logs/app.log ]; then
    echo "æœ€è¿‘5æ¡é”™è¯¯:"
    grep -i error logs/app.log | tail -5
else
    echo "æœªæ‰¾åˆ°åº”ç”¨æ—¥å¿—æ–‡ä»¶"
fi

echo "========== è¯Šæ–­å®Œæˆ =========="
```

### æ€§èƒ½ç›‘æ§è„šæœ¬

```python
#!/usr/bin/env python3
# scripts/performance_monitor.py

import time
import psutil
import requests
import json
from datetime import datetime

class PerformanceMonitor:
    def __init__(self):
        self.api_url = "http://localhost:5000"
        self.check_interval = 60  # ç§’
    
    def get_system_metrics(self):
        """è·å–ç³»ç»ŸæŒ‡æ ‡"""
        return {
            'timestamp': datetime.now().isoformat(),
            'cpu_percent': psutil.cpu_percent(interval=1),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_usage': psutil.disk_usage('/').percent,
            'network_io': dict(psutil.net_io_counters()._asdict()),
            'process_count': len(psutil.pids())
        }
    
    def get_application_metrics(self):
        """è·å–åº”ç”¨æŒ‡æ ‡"""
        try:
            # APIå“åº”æ—¶é—´
            start_time = time.time()
            response = requests.get(f"{self.api_url}/health", timeout=10)
            response_time = (time.time() - start_time) * 1000
            
            return {
                'api_response_time': response_time,
                'api_status_code': response.status_code,
                'api_available': response.status_code == 200
            }
        except Exception as e:
            return {
                'api_response_time': None,
                'api_status_code': None,
                'api_available': False,
                'error': str(e)
            }
    
    def check_alerts(self, metrics):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        alerts = []
        
        if metrics['cpu_percent'] > 80:
            alerts.append(f"CPUä½¿ç”¨ç‡è¿‡é«˜: {metrics['cpu_percent']:.1f}%")
        
        if metrics['memory_percent'] > 85:
            alerts.append(f"å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {metrics['memory_percent']:.1f}%")
        
        if metrics['disk_usage'] > 90:
            alerts.append(f"ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: {metrics['disk_usage']:.1f}%")
        
        if metrics.get('api_response_time', 0) > 5000:
            alerts.append(f"APIå“åº”æ—¶é—´è¿‡é•¿: {metrics['api_response_time']:.0f}ms")
        
        if not metrics.get('api_available', True):
            alerts.append("APIæœåŠ¡ä¸å¯ç”¨")
        
        return alerts
    
    def run(self):
        """è¿è¡Œç›‘æ§"""
        print("æ€§èƒ½ç›‘æ§å¯åŠ¨...")
        
        while True:
            try:
                # æ”¶é›†æŒ‡æ ‡
                system_metrics = self.get_system_metrics()
                app_metrics = self.get_application_metrics()
                
                all_metrics = {**system_metrics, **app_metrics}
                
                # æ£€æŸ¥å‘Šè­¦
                alerts = self.check_alerts(all_metrics)
                
                # è¾“å‡ºçŠ¶æ€
                print(f"\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"CPU: {system_metrics['cpu_percent']:.1f}% | "
                      f"å†…å­˜: {system_metrics['memory_percent']:.1f}% | "
                      f"ç£ç›˜: {system_metrics['disk_usage']:.1f}% | "
                      f"API: {app_metrics.get('api_response_time', 'N/A')}ms")
                
                # è¾“å‡ºå‘Šè­¦
                for alert in alerts:
                    print(f"ğŸš¨ {alert}")
                
                # ä¿å­˜æŒ‡æ ‡åˆ°æ–‡ä»¶
                with open('logs/performance.jsonl', 'a') as f:
                    f.write(json.dumps(all_metrics) + '\n')
                
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                print("\nç›‘æ§åœæ­¢")
                break
            except Exception as e:
                print(f"ç›‘æ§é”™è¯¯: {e}")
                time.sleep(self.check_interval)

if __name__ == "__main__":
    monitor = PerformanceMonitor()
    monitor.run()
```

### è‡ªåŠ¨ä¿®å¤è„šæœ¬

```bash
#!/bin/bash
# scripts/auto_fix.sh - è‡ªåŠ¨ä¿®å¤å¸¸è§é—®é¢˜

echo "å¼€å§‹è‡ªåŠ¨ä¿®å¤..."

# ä¿®å¤æƒé™é—®é¢˜
echo "ä¿®å¤æ–‡ä»¶æƒé™..."
chmod +x run_monitor.py
chmod +x scripts/*.sh
chown -R $USER:$USER logs/
chmod 755 logs/

# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
echo "æ¸…ç†ä¸´æ—¶æ–‡ä»¶..."
find . -name "*.pyc" -delete
find . -name "__pycache__" -type d -exec rm -rf {} +
find . -name "*.log.*" -mtime +7 -delete

# é‡å¯æœåŠ¡
echo "é‡å¯æœåŠ¡..."
sudo systemctl restart redis
sudo systemctl restart mysql

# æ£€æŸ¥å¹¶ä¿®å¤æ•°æ®åº“è¿æ¥
echo "æ£€æŸ¥æ•°æ®åº“è¿æ¥..."
if ! mysql -u lianghua -p"$DB_PASSWORD" -e "SELECT 1;" 2>/dev/null; then
    echo "é‡ç½®æ•°æ®åº“è¿æ¥..."
    sudo systemctl restart mysql
    sleep 5
fi

# æ¸…ç†Redisç¼“å­˜
echo "æ¸…ç†Redisç¼“å­˜..."
redis-cli FLUSHDB

# é‡æ–°å®‰è£…ä¾èµ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
if [ "$1" == "--reinstall" ]; then
    echo "é‡æ–°å®‰è£…Pythonä¾èµ–..."
    pip install --upgrade --force-reinstall -r requirements.txt
fi

echo "è‡ªåŠ¨ä¿®å¤å®Œæˆï¼"
```

## ğŸ“ æ”¯æŒå’Œè”ç³»

### è·å–å¸®åŠ©

1. **æŸ¥çœ‹æ–‡æ¡£**ï¼šä¼˜å…ˆæŸ¥é˜…ç›¸å…³æŠ€æœ¯æ–‡æ¡£
2. **æœç´¢å·²çŸ¥é—®é¢˜**ï¼šæ£€æŸ¥issueåˆ—è¡¨æˆ–FAQ
3. **æ—¥å¿—åˆ†æ**ï¼šæ”¶é›†è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
4. **ç¯å¢ƒä¿¡æ¯**ï¼šå‡†å¤‡ç³»ç»Ÿå’Œè½¯ä»¶ç‰ˆæœ¬ä¿¡æ¯

### æŠ¥å‘Šé—®é¢˜

æäº¤é—®é¢˜æ—¶è¯·åŒ…å«ï¼š

```
1. é—®é¢˜æè¿°ï¼šè¯¦ç»†æè¿°é‡åˆ°çš„é—®é¢˜
2. å¤ç°æ­¥éª¤ï¼šå¦‚ä½•è§¦å‘è¿™ä¸ªé—®é¢˜
3. é¢„æœŸè¡Œä¸ºï¼šæœŸæœ›çš„æ­£ç¡®è¡Œä¸º
4. å®é™…è¡Œä¸ºï¼šå®é™…å‘ç”Ÿçš„æƒ…å†µ
5. ç¯å¢ƒä¿¡æ¯ï¼šæ“ä½œç³»ç»Ÿã€Pythonç‰ˆæœ¬ã€ä¾èµ–ç‰ˆæœ¬
6. é”™è¯¯æ—¥å¿—ï¼šç›¸å…³çš„é”™è¯¯ä¿¡æ¯å’Œå †æ ˆè·Ÿè¸ª
7. é…ç½®æ–‡ä»¶ï¼šç›¸å…³çš„é…ç½®è®¾ç½®ï¼ˆå»é™¤æ•æ„Ÿä¿¡æ¯ï¼‰
```

### ç´§æ€¥è”ç³»æ–¹å¼

- **æŠ€æœ¯æ”¯æŒé‚®ç®±**ï¼šsupport@lianghua.com
- **é—®é¢˜è·Ÿè¸ª**ï¼šGitHub Issues
- **æ–‡æ¡£åé¦ˆ**ï¼šdocs@lianghua.com

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´8æœˆ18æ—¥  
**ç»´æŠ¤å›¢é˜Ÿ**: æŠ€æœ¯æ”¯æŒå›¢é˜Ÿ