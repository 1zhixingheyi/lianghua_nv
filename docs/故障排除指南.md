# 量化交易系统故障排除指南

## 📋 概述

本指南帮助用户和运维人员快速诊断和解决量化交易系统运行过程中遇到的常见问题。涵盖系统启动、数据获取、策略运行、交易执行、性能优化等各个方面的故障处理。

## 🚨 快速诊断

### 系统健康检查

#### 1. 基础服务检查
```bash
# 检查系统服务状态
sudo systemctl status mysql redis nginx

# 检查端口占用
netstat -tlnp | grep -E '(3306|6379|5000|80|443)'

# 检查进程状态
ps aux | grep -E '(python|mysql|redis|nginx)'

# 检查磁盘空间
df -h

# 检查内存使用
free -h

# 检查CPU负载
top -bn1 | head -5
```

#### 2. 应用服务检查
```bash
# 检查应用健康状态
curl -f http://localhost:5000/health

# 检查API响应
curl -f http://localhost:5000/api/dashboard/summary

# 检查WebSocket连接
python -c "
import websocket
try:
    ws = websocket.create_connection('ws://localhost:5000/ws')
    print('WebSocket连接正常')
    ws.close()
except Exception as e:
    print(f'WebSocket连接失败: {e}')
"

# 检查数据库连接
python -c "
from data.database import get_database_manager
try:
    db = get_database_manager()
    print('数据库连接正常')
except Exception as e:
    print(f'数据库连接失败: {e}')
"
```

#### 3. 日志快速检查
```bash
# 查看应用错误日志
tail -50 logs/app.log | grep -i error

# 查看系统错误日志
journalctl -u lianghua_vn --since "1 hour ago" | grep -i error

# 查看Nginx错误日志
tail -50 /var/log/nginx/error.log

# 查看MySQL错误日志
tail -50 /var/log/mysql/error.log
```

## 🔧 常见问题解决

### 1. 系统启动问题

#### 问题：应用启动失败
**症状**：
- `python run_monitor.py` 无法启动
- 提示模块导入错误
- 端口占用错误

**解决方案**：

```bash
# 检查Python环境
python --version
which python

# 检查虚拟环境
source venv/bin/activate
pip list

# 重新安装依赖
pip install --upgrade -r requirements.txt

# 检查端口占用
lsof -i :5000
# 如果端口被占用，杀死进程
sudo kill -9 <PID>

# 检查环境变量
cat .env
export FLASK_ENV=development

# 清理Python缓存
find . -name "*.pyc" -delete
find . -name "__pycache__" -delete
```

#### 问题：数据库连接失败
**症状**：
- `Connection refused` 错误
- `Access denied` 错误
- 数据库超时

**解决方案**：

```bash
# 检查MySQL服务
sudo systemctl status mysql
sudo systemctl start mysql

# 检查数据库配置
mysql -u root -p -e "SHOW DATABASES;"

# 测试数据库连接
mysql -h localhost -u lianghua -p lianghua_trading -e "SELECT 1;"

# 重置数据库密码
sudo mysql -u root -p
ALTER USER 'lianghua'@'localhost' IDENTIFIED BY 'new_password';
FLUSH PRIVILEGES;

# 检查防火墙
sudo ufw status
sudo ufw allow 3306

# 修复数据库权限
GRANT ALL PRIVILEGES ON lianghua_trading.* TO 'lianghua'@'localhost';
FLUSH PRIVILEGES;
```

#### 问题：Redis连接失败
**症状**：
- Redis连接超时
- 认证失败
- 内存不足

**解决方案**：

```bash
# 检查Redis服务
sudo systemctl status redis
sudo systemctl start redis

# 测试Redis连接
redis-cli ping
redis-cli -a password ping

# 检查Redis配置
sudo vim /etc/redis/redis.conf
# 修改：
# bind 127.0.0.1
# requirepass your_password

# 清理Redis内存
redis-cli FLUSHDB
redis-cli FLUSHALL

# 检查内存使用
redis-cli INFO memory

# 重启Redis服务
sudo systemctl restart redis
```

### 2. 数据获取问题

#### 问题：Tushare数据获取失败
**症状**：
- API调用频率限制
- Token无效
- 数据缺失

**解决方案**：

```python
# 检查Token有效性
import tushare as ts
ts.set_token('your_token')
pro = ts.pro_api()

try:
    df = pro.stock_basic(exchange='', list_status='L', fields='ts_code,symbol,name')
    print("Token有效，数据获取正常")
except Exception as e:
    print(f"Token或网络问题: {e}")

# 检查API调用频率
import time

def safe_api_call(func, *args, **kwargs):
    max_retries = 3
    for i in range(max_retries):
        try:
            result = func(*args, **kwargs)
            return result
        except Exception as e:
            if "频率" in str(e) or "limit" in str(e).lower():
                wait_time = (i + 1) * 60  # 递增等待时间
                print(f"API调用频率限制，等待{wait_time}秒...")
                time.sleep(wait_time)
            else:
                raise e
    raise Exception("API调用失败，已达最大重试次数")

# 使用示例
df = safe_api_call(pro.daily, ts_code='000001.SZ', start_date='20230101')
```

#### 问题：数据更新延迟
**症状**：
- 股价数据不是最新的
- 指标计算错误
- 回测结果异常

**解决方案**：

```python
# 手动更新数据
from data.data_manager import DataManager

dm = DataManager()

# 更新股票基础信息
dm.update_stock_basic()

# 更新日线数据
dm.update_daily_data()

# 检查数据完整性
symbols = ['000001.SZ', '000002.SZ', '600000.SH']
for symbol in symbols:
    latest_date = dm.get_latest_date(symbol)
    print(f"{symbol} 最新数据日期: {latest_date}")

# 数据验证
import pandas as pd
from datetime import datetime, timedelta

today = datetime.now().date()
trade_dates = dm.get_trade_dates(today - timedelta(days=30), today)
missing_dates = []

for date in trade_dates:
    data_count = dm.get_daily_data_count(date)
    if data_count < 3000:  # 假设市场有3000+股票
        missing_dates.append(date)

if missing_dates:
    print(f"缺失数据的日期: {missing_dates}")
```

### 3. 策略运行问题

#### 问题：策略报错
**症状**：
- 策略初始化失败
- 指标计算错误
- 订单生成异常

**解决方案**：

```python
# 策略调试模式
import logging
logging.basicConfig(level=logging.DEBUG)

from strategies.rsi_strategy import RSIStrategy

# 创建测试环境
class MockContext:
    def __init__(self):
        self.portfolio = MockPortfolio()
        self.universe = ['000001.SZ']

class MockPortfolio:
    def __init__(self):
        self.total_value = 1000000
        self.cash = 1000000
        self.positions = {}

# 测试策略
try:
    strategy = RSIStrategy('test_rsi', {
        'symbol': '000001.SZ',
        'rsi_period': 14,
        'rsi_upper': 70,
        'rsi_lower': 30
    })
    
    context = MockContext()
    strategy.initialize(context)
    print("策略初始化成功")
    
except Exception as e:
    print(f"策略错误: {e}")
    import traceback
    traceback.print_exc()

# 参数验证
def validate_strategy_params(strategy_class, params):
    required_params = getattr(strategy_class, 'REQUIRED_PARAMS', [])
    for param in required_params:
        if param not in params:
            raise ValueError(f"缺少必需参数: {param}")
    
    # 参数范围检查
    if 'rsi_period' in params and not (1 <= params['rsi_period'] <= 100):
        raise ValueError("RSI周期必须在1-100之间")
        
    if 'rsi_upper' in params and not (50 <= params['rsi_upper'] <= 100):
        raise ValueError("RSI上限必须在50-100之间")
```

#### 问题：回测结果异常
**症状**：
- 收益率过高或过低
- 夏普比率异常
- 最大回撤过大

**解决方案**：

```python
# 回测结果验证
from backtest.engine import BacktestEngine
from backtest.performance import PerformanceAnalyzer

def validate_backtest_results(results):
    """验证回测结果合理性"""
    
    # 检查基本指标
    if results['total_return'] > 10:  # 年化收益率超过1000%
        print("警告：收益率异常过高，可能存在未来函数")
    
    if results['sharpe_ratio'] > 5:  # 夏普比率过高
        print("警告：夏普比率异常，检查风险计算")
    
    if results['max_drawdown'] > 0.8:  # 最大回撤超过80%
        print("警告：最大回撤过大，检查风控设置")
    
    # 检查交易频率
    trading_days = len(results['daily_returns'])
    total_trades = results['total_trades']
    if total_trades / trading_days > 2:  # 平均每天交易超过2次
        print("警告：交易频率过高，可能影响成本")
    
    # 检查胜率
    win_rate = results['win_rate']
    if win_rate > 0.9 or win_rate < 0.3:
        print(f"警告：胜率异常 ({win_rate:.2%})，检查信号逻辑")

# 分步调试回测
def debug_backtest(strategy, start_date, end_date):
    """分步调试回测过程"""
    
    engine = BacktestEngine(strategy, start_date, end_date, 1000000)
    
    # 检查数据
    data = engine.get_data()
    print(f"数据范围: {data.index.min()} 到 {data.index.max()}")
    print(f"数据点数: {len(data)}")
    
    # 检查信号
    signals = engine.generate_signals()
    print(f"信号数量: {len(signals)}")
    print(f"买入信号: {sum(1 for s in signals if s['action'] == 'buy')}")
    print(f"卖出信号: {sum(1 for s in signals if s['action'] == 'sell')}")
    
    # 逐日执行
    for i, (date, row) in enumerate(data.iterrows()):
        if i % 100 == 0:  # 每100天打印一次状态
            portfolio_value = engine.get_portfolio_value(date)
            print(f"日期: {date}, 组合价值: {portfolio_value:,.2f}")
```

### 4. 交易执行问题

#### 问题：QMT连接失败
**症状**：
- 无法连接到QMT客户端
- 登录失败
- 交易权限不足

**解决方案**：

```python
# QMT连接诊断
from trading.qmt_trader import QMTTrader

def diagnose_qmt_connection():
    """诊断QMT连接问题"""
    
    try:
        # 检查QMT进程
        import psutil
        qmt_processes = [p for p in psutil.process_iter() if 'qmt' in p.name().lower()]
        if not qmt_processes:
            print("错误：QMT客户端未运行")
            return False
        
        # 尝试连接
        trader = QMTTrader()
        
        # 检查登录状态
        if not trader.is_logged_in():
            print("错误：QMT未登录")
            return False
        
        # 检查账户信息
        account_info = trader.get_account_info()
        print(f"账户信息: {account_info}")
        
        # 检查交易权限
        permissions = trader.get_trading_permissions()
        if not permissions.get('stock_trading', False):
            print("错误：股票交易权限不足")
            return False
        
        print("QMT连接正常")
        return True
        
    except Exception as e:
        print(f"QMT连接错误: {e}")
        return False

# QMT配置检查
def check_qmt_config():
    """检查QMT配置"""
    
    import os
    from config import QMT_CONFIG
    
    # 检查QMT路径
    qmt_path = QMT_CONFIG.get('path')
    if not os.path.exists(qmt_path):
        print(f"错误：QMT路径不存在: {qmt_path}")
        return False
    
    # 检查端口配置
    port = QMT_CONFIG.get('port', 58610)
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    result = sock.connect_ex(('localhost', port))
    sock.close()
    
    if result != 0:
        print(f"错误：QMT端口 {port} 无法连接")
        return False
    
    return True
```

#### 问题：订单执行失败
**症状**：
- 订单被拒绝
- 价格偏差过大
- 资金不足

**解决方案**：

```python
# 订单验证和重试机制
class OrderManager:
    def __init__(self):
        self.max_retries = 3
        self.retry_delay = 1  # 秒
    
    def place_order_with_retry(self, symbol, quantity, price, order_type):
        """带重试的下单"""
        
        for attempt in range(self.max_retries):
            try:
                # 预检查
                if not self.pre_order_check(symbol, quantity, price):
                    return None
                
                # 执行下单
                order_id = self.trader.place_order(symbol, quantity, price, order_type)
                
                # 验证订单
                if self.verify_order(order_id):
                    return order_id
                
            except Exception as e:
                print(f"下单失败 (尝试 {attempt + 1}/{self.max_retries}): {e}")
                
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay * (attempt + 1))
                else:
                    print("下单失败，已达最大重试次数")
                    raise
        
        return None
    
    def pre_order_check(self, symbol, quantity, price):
        """订单预检查"""
        
        # 检查资金
        account_info = self.trader.get_account_info()
        required_cash = quantity * price * 1.01  # 加1%缓冲
        
        if account_info['available_cash'] < required_cash:
            print(f"资金不足: 需要 {required_cash:,.2f}, 可用 {account_info['available_cash']:,.2f}")
            return False
        
        # 检查价格合理性
        current_price = self.get_current_price(symbol)
        if abs(price - current_price) / current_price > 0.1:  # 价格偏差超过10%
            print(f"价格偏差过大: 当前 {current_price}, 委托 {price}")
            return False
        
        # 检查股票状态
        stock_info = self.get_stock_info(symbol)
        if stock_info['status'] != 'trading':
            print(f"股票 {symbol} 停牌或异常")
            return False
        
        return True
```

### 5. 性能问题

#### 问题：系统响应慢
**症状**：
- 页面加载缓慢
- API响应超时
- 内存使用过高

**解决方案**：

```bash
# 性能监控
# 1. 检查系统资源
htop
iotop
nethogs

# 2. 检查数据库性能
# MySQL慢查询
sudo mysql -e "
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;
SHOW VARIABLES LIKE 'slow_query%';
"

# 分析慢查询日志
sudo mysqldumpslow /var/log/mysql/slow.log

# 3. 检查Redis性能
redis-cli INFO stats
redis-cli SLOWLOG GET 10

# 4. 应用性能分析
python -m cProfile -o profile.stats run_monitor.py
python -c "
import pstats
p = pstats.Stats('profile.stats')
p.sort_stats('cumulative').print_stats(20)
"
```

#### 问题：内存泄漏
**症状**：
- 内存使用持续增长
- 系统变慢
- OOM错误

**解决方案**：

```python
# 内存监控和诊断
import psutil
import gc
import tracemalloc

class MemoryMonitor:
    def __init__(self):
        self.start_memory = psutil.Process().memory_info().rss
        tracemalloc.start()
    
    def check_memory(self, operation_name):
        """检查内存使用"""
        current_memory = psutil.Process().memory_info().rss
        memory_diff = current_memory - self.start_memory
        
        print(f"{operation_name}: 内存使用 {current_memory / 1024 / 1024:.1f}MB "
              f"(增长 {memory_diff / 1024 / 1024:.1f}MB)")
        
        # 检查内存增长
        if memory_diff > 100 * 1024 * 1024:  # 超过100MB
            print("警告：内存使用异常增长")
            self.dump_memory_usage()
    
    def dump_memory_usage(self):
        """输出内存使用详情"""
        snapshot = tracemalloc.take_snapshot()
        top_stats = snapshot.statistics('lineno')
        
        print("内存使用TOP 10:")
        for index, stat in enumerate(top_stats[:10], 1):
            print(f"{index}. {stat}")

# 使用示例
monitor = MemoryMonitor()

# 在关键操作后检查内存
data = load_large_dataset()
monitor.check_memory("加载数据集")

results = run_backtest()
monitor.check_memory("运行回测")

# 强制垃圾回收
gc.collect()
monitor.check_memory("垃圾回收后")
```

### 6. 网络问题

#### 问题：数据源连接超时
**症状**：
- Tushare API超时
- 网络请求失败
- 代理配置问题

**解决方案**：

```python
# 网络连接诊断和重试
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

class RobustHTTPSession:
    def __init__(self):
        self.session = requests.Session()
        
        # 配置重试策略
        retry_strategy = Retry(
            total=3,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["HEAD", "GET", "OPTIONS"],
            backoff_factor=1
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        # 设置超时
        self.session.timeout = 30
        
        # 设置代理（如果需要）
        # self.session.proxies = {'http': 'proxy:port', 'https': 'proxy:port'}
    
    def get(self, url, **kwargs):
        """安全的GET请求"""
        try:
            response = self.session.get(url, **kwargs)
            response.raise_for_status()
            return response
        except requests.exceptions.Timeout:
            print(f"请求超时: {url}")
            raise
        except requests.exceptions.ConnectionError:
            print(f"连接错误: {url}")
            raise
        except requests.exceptions.HTTPError as e:
            print(f"HTTP错误: {e}")
            raise

# 网络诊断工具
def diagnose_network():
    """网络诊断"""
    
    import subprocess
    
    # 检查DNS解析
    try:
        result = subprocess.run(['nslookup', 'api.tushare.pro'], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            print("DNS解析正常")
        else:
            print("DNS解析失败")
    except subprocess.TimeoutExpired:
        print("DNS查询超时")
    
    # 检查网络连通性
    test_urls = [
        'https://api.tushare.pro',
        'https://www.baidu.com',
        'https://www.google.com'
    ]
    
    session = RobustHTTPSession()
    for url in test_urls:
        try:
            response = session.get(url)
            print(f"✓ {url} - 状态码: {response.status_code}")
        except Exception as e:
            print(f"✗ {url} - 错误: {e}")
```

## 📊 日志分析

### 日志级别说明

```python
# 日志级别和含义
logging.DEBUG    # 调试信息，详细的执行流程
logging.INFO     # 一般信息，正常的业务流程
logging.WARNING  # 警告信息，潜在问题
logging.ERROR    # 错误信息，程序异常但可继续
logging.CRITICAL # 严重错误，程序无法继续
```

### 常见日志模式

#### 1. 错误日志分析
```bash
# 查找错误模式
grep -E "(ERROR|CRITICAL)" logs/app.log | tail -20

# 统计错误类型
grep "ERROR" logs/app.log | awk '{print $5}' | sort | uniq -c | sort -nr

# 查找特定时间段的错误
grep "2023-12-01" logs/app.log | grep "ERROR"

# 分析错误趋势
for hour in {00..23}; do
    count=$(grep "2023-12-01 $hour:" logs/app.log | grep "ERROR" | wc -l)
    echo "$hour:00 - $count errors"
done
```

#### 2. 性能日志分析
```bash
# 查找慢请求
grep "执行时间" logs/app.log | awk '$NF > 5' | tail -10

# 分析API响应时间
grep "API响应时间" logs/app.log | awk '{print $NF}' | sort -n | tail -10

# 统计请求量
grep "API请求" logs/app.log | awk '{print $2}' | cut -d: -f1 | sort | uniq -c
```

### 日志告警规则

```python
# 日志监控脚本
import re
import time
from collections import defaultdict

class LogMonitor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.error_patterns = [
            r'ERROR.*Database connection failed',
            r'CRITICAL.*Out of memory',
            r'ERROR.*Strategy.*failed',
            r'WARNING.*High memory usage'
        ]
        self.alert_thresholds = {
            'error_rate': 10,  # 每分钟错误数
            'memory_usage': 80,  # 内存使用百分比
            'response_time': 5000  # 响应时间毫秒
        }
    
    def monitor(self):
        """监控日志文件"""
        error_counts = defaultdict(int)
        
        with open(self.log_file, 'r') as f:
            f.seek(0, 2)  # 移到文件末尾
            
            while True:
                line = f.readline()
                if not line:
                    time.sleep(1)
                    continue
                
                # 检查错误模式
                for pattern in self.error_patterns:
                    if re.search(pattern, line):
                        error_counts[pattern] += 1
                        
                        # 发送告警
                        self.send_alert(pattern, line)
                
                # 重置计数器（每分钟）
                if int(time.time()) % 60 == 0:
                    error_counts.clear()
    
    def send_alert(self, pattern, log_line):
        """发送告警"""
        print(f"ALERT: {pattern} - {log_line.strip()}")
        # 这里可以集成邮件、短信、钉钉等告警方式
```

## 🔧 工具和脚本

### 诊断脚本

```bash
#!/bin/bash
# scripts/system_check.sh - 系统诊断脚本

echo "========== 系统诊断报告 =========="
echo "时间: $(date)"
echo

echo "1. 系统信息:"
uname -a
echo "CPU核心数: $(nproc)"
echo "内存总量: $(free -h | grep Mem | awk '{print $2}')"
echo "磁盘使用: $(df -h / | tail -1 | awk '{print $5}')"
echo

echo "2. 服务状态:"
for service in mysql redis nginx; do
    if systemctl is-active --quiet $service; then
        echo "✓ $service 运行中"
    else
        echo "✗ $service 未运行"
    fi
done
echo

echo "3. 端口检查:"
for port in 3306 6379 5000 80 443; do
    if netstat -tlnp | grep -q ":$port "; then
        echo "✓ 端口 $port 已监听"
    else
        echo "✗ 端口 $port 未监听"
    fi
done
echo

echo "4. 应用健康检查:"
if curl -sf http://localhost:5000/health > /dev/null; then
    echo "✓ 应用健康检查通过"
else
    echo "✗ 应用健康检查失败"
fi
echo

echo "5. 最近错误日志:"
if [ -f logs/app.log ]; then
    echo "最近5条错误:"
    grep -i error logs/app.log | tail -5
else
    echo "未找到应用日志文件"
fi

echo "========== 诊断完成 =========="
```

### 性能监控脚本

```python
#!/usr/bin/env python3
# scripts/performance_monitor.py

import time
import psutil
import requests
import json
from datetime import datetime

class PerformanceMonitor:
    def __init__(self):
        self.api_url = "http://localhost:5000"
        self.check_interval = 60  # 秒
    
    def get_system_metrics(self):
        """获取系统指标"""
        return {
            'timestamp': datetime.now().isoformat(),
            'cpu_percent': psutil.cpu_percent(interval=1),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_usage': psutil.disk_usage('/').percent,
            'network_io': dict(psutil.net_io_counters()._asdict()),
            'process_count': len(psutil.pids())
        }
    
    def get_application_metrics(self):
        """获取应用指标"""
        try:
            # API响应时间
            start_time = time.time()
            response = requests.get(f"{self.api_url}/health", timeout=10)
            response_time = (time.time() - start_time) * 1000
            
            return {
                'api_response_time': response_time,
                'api_status_code': response.status_code,
                'api_available': response.status_code == 200
            }
        except Exception as e:
            return {
                'api_response_time': None,
                'api_status_code': None,
                'api_available': False,
                'error': str(e)
            }
    
    def check_alerts(self, metrics):
        """检查告警条件"""
        alerts = []
        
        if metrics['cpu_percent'] > 80:
            alerts.append(f"CPU使用率过高: {metrics['cpu_percent']:.1f}%")
        
        if metrics['memory_percent'] > 85:
            alerts.append(f"内存使用率过高: {metrics['memory_percent']:.1f}%")
        
        if metrics['disk_usage'] > 90:
            alerts.append(f"磁盘使用率过高: {metrics['disk_usage']:.1f}%")
        
        if metrics.get('api_response_time', 0) > 5000:
            alerts.append(f"API响应时间过长: {metrics['api_response_time']:.0f}ms")
        
        if not metrics.get('api_available', True):
            alerts.append("API服务不可用")
        
        return alerts
    
    def run(self):
        """运行监控"""
        print("性能监控启动...")
        
        while True:
            try:
                # 收集指标
                system_metrics = self.get_system_metrics()
                app_metrics = self.get_application_metrics()
                
                all_metrics = {**system_metrics, **app_metrics}
                
                # 检查告警
                alerts = self.check_alerts(all_metrics)
                
                # 输出状态
                print(f"\n{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"CPU: {system_metrics['cpu_percent']:.1f}% | "
                      f"内存: {system_metrics['memory_percent']:.1f}% | "
                      f"磁盘: {system_metrics['disk_usage']:.1f}% | "
                      f"API: {app_metrics.get('api_response_time', 'N/A')}ms")
                
                # 输出告警
                for alert in alerts:
                    print(f"🚨 {alert}")
                
                # 保存指标到文件
                with open('logs/performance.jsonl', 'a') as f:
                    f.write(json.dumps(all_metrics) + '\n')
                
                time.sleep(self.check_interval)
                
            except KeyboardInterrupt:
                print("\n监控停止")
                break
            except Exception as e:
                print(f"监控错误: {e}")
                time.sleep(self.check_interval)

if __name__ == "__main__":
    monitor = PerformanceMonitor()
    monitor.run()
```

### 自动修复脚本

```bash
#!/bin/bash
# scripts/auto_fix.sh - 自动修复常见问题

echo "开始自动修复..."

# 修复权限问题
echo "修复文件权限..."
chmod +x run_monitor.py
chmod +x scripts/*.sh
chown -R $USER:$USER logs/
chmod 755 logs/

# 清理临时文件
echo "清理临时文件..."
find . -name "*.pyc" -delete
find . -name "__pycache__" -type d -exec rm -rf {} +
find . -name "*.log.*" -mtime +7 -delete

# 重启服务
echo "重启服务..."
sudo systemctl restart redis
sudo systemctl restart mysql

# 检查并修复数据库连接
echo "检查数据库连接..."
if ! mysql -u lianghua -p"$DB_PASSWORD" -e "SELECT 1;" 2>/dev/null; then
    echo "重置数据库连接..."
    sudo systemctl restart mysql
    sleep 5
fi

# 清理Redis缓存
echo "清理Redis缓存..."
redis-cli FLUSHDB

# 重新安装依赖（如果需要）
if [ "$1" == "--reinstall" ]; then
    echo "重新安装Python依赖..."
    pip install --upgrade --force-reinstall -r requirements.txt
fi

echo "自动修复完成！"
```

## 📞 支持和联系

### 获取帮助

1. **查看文档**：优先查阅相关技术文档
2. **搜索已知问题**：检查issue列表或FAQ
3. **日志分析**：收集详细的错误日志
4. **环境信息**：准备系统和软件版本信息

### 报告问题

提交问题时请包含：

```
1. 问题描述：详细描述遇到的问题
2. 复现步骤：如何触发这个问题
3. 预期行为：期望的正确行为
4. 实际行为：实际发生的情况
5. 环境信息：操作系统、Python版本、依赖版本
6. 错误日志：相关的错误信息和堆栈跟踪
7. 配置文件：相关的配置设置（去除敏感信息）
```

### 紧急联系方式

- **技术支持邮箱**：support@lianghua.com
- **问题跟踪**：GitHub Issues
- **文档反馈**：docs@lianghua.com

---

**文档版本**: v1.0  
**最后更新**: 2025年8月18日  
**维护团队**: 技术支持团队